angular.module("debate-visualization")
  .directive("debateCharts", () ->
    return {
        restrict: 'E',
        templateUrl: "<%= asset_path 'debateCharts/layout/layout.html' %>",
        scope: {
          debate: '=',
          posColor: '=',
          negColor: '='
        },

        link: (scope, element, attrs) ->
          row = $(element.children()[0])

          # Positioning
          boxDom     = row.find(".box-plot")[0];
          boxRect    = boxDom.getBoundingClientRect();
          boxWidth   = boxRect.width;
          boxHeight  = boxWidth;

          pieDom    = row.find(".pie-chart")[0];
          pieRect   = pieDom.getBoundingClientRect();
          pieWidth  = pieRect.width;
          pieHeigt  = pieWidth;
          pieRadius = pieWidth/4;

          bubbleDom     = row.find(".bubble-chart")[0];
          bubbleRect    = bubbleDom.getBoundingClientRect();
          bubbleWidth   = bubbleRect.width;
          bubbleHeight  = bubbleWidth/2;

          # Colors
          posColor = scope.posColor.toHexString();
          posColorLight = scope.posColor.clone().lighten(50).toHexString();
          negColor = scope.negColor.toHexString();
          negColorLight = scope.negColor.clone().lighten(50).toHexString();

          # Ordinal scale for charts
          color_scale_ord = d3.scale.ordinal()
            .domain(['positive', 'negative'])
            .range([posColor, negColor]);

          # Only render once data is populated
          scope.$watch('debate', (newVal, oldVal) ->
            if newVal == undefined || newVal == null then return;
            # Charts
            chart   = dc.boxPlot(boxDom);
            pie     = dc.pieChart(pieDom);
            bubble  = dc.bubbleChart(bubbleDom);

            # Crossfilter
            words = crossfilter(scope.debate);

            # Dimensions
            sentimentDimension      = words.dimension( (d) -> return if d.average_sentiment > 0 then 'positive' else 'negative');
            sentimentDimensionCopy  = words.dimension( (d) -> return if d.average_sentiment > 0 then 'positive' else 'negative');
            wordDimension           = words.dimension( (d) -> return d.text);

            # Groups
            sentimentCount = sentimentDimensionCopy.group().reduceCount();

            addSentiment = (p,v) ->
              p.push(v.average_sentiment);
              return p;
            removeSentiment = (p,v) ->
              p.splice(p.indexOf(v.average_sentiment), 1);
              return p;
            initSentiment = () ->
              return [];
            sentimentGroup = sentimentDimension.group().reduce(addSentiment, removeSentiment, initSentiment);

            addWord = (p,v) ->
              p.freq += v.count;
              p.sentiment += v.average_sentiment;
              return p;
            removeWord = (p,v) ->
              p.freq -= v.count;
              p.sentiment -= v.average_sentiment;
              return p;
            initWord = () ->
              return {
                freq: 0,
                sentiment: 0
              };
            wordGroup = wordDimension.group().reduce(addWord, removeWord, initWord);

            chart.width(boxWidth)
              .height(boxHeight)
              .margins({top: 20, right: 30, bottom: 30, left: 35})
              .dimension(sentimentDimension)
              .group(sentimentGroup)
              .y(d3.scale.linear().domain([-1, 1]))
              .elasticX(true)
              .colors(color_scale_ord)
              .xAxisLabel("Overall Sentiment")
              .yAxisLabel("Sentiment Intensity")

            pie.width(pieWidth)
              .height(pieHeigt)
              .radius(pieRadius)
              .dimension(sentimentDimensionCopy)
              .group(sentimentCount)
              .colors(color_scale_ord)
              .label((d) -> return d.key + " [#{d.value}]";)

            bubble.width(bubbleWidth)
              .height(bubbleHeight)
              .margins({top: 10, right: 30, bottom: 30, left: 35})
              .dimension(wordDimension)
              .group(wordGroup)
              .colors(color_scale_ord)
              .colorAccessor((d) -> return if d.value.sentiment > 0 then 'positive' else 'negative')
              .keyAccessor((d) -> return d.value.sentiment)
              .valueAccessor((d) -> return d.value.freq)
              .radiusValueAccessor((d) -> return d.value.freq)
              .maxBubbleRelativeSize(0.05)
              .x(d3.scale.linear().domain([-1, 1]))
              .y(d3.scale.linear().domain([0, 100]))
              .r(d3.scale.linear().domain([0,100]))
              .elasticY(true)
              .elasticX(true)
              .elasticRadius(true)
              .renderHorizontalGridLines(true)
              .renderVerticalGridLines(true)
              .yAxisPadding(20)
              .xAxisPadding(0.25)
              .xAxisLabel('Sentiment Value')
              .yAxisLabel('Frequency')
              .renderLabel(true)
              .label( (d) ->
                return d.key;
              )
              .renderTitle(true)
              .title( (d) ->
                  return [
                      d.key,
                      "Sentiment Score: #{d.value.sentiment}",
                      "Frequency #{d.value.freq}"
                  ].join('\n');
              );

            dc.renderAll();
            scope.$emit("render-done", element);
          );
    };  # return
  );
